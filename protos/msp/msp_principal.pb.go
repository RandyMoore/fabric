// Code generated by protoc-gen-gogo.
// source: msp/msp_principal.proto
// DO NOT EDIT!

package msp

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type MSPPrincipal_Classification int32

const (
	MSPPrincipal_ROLE MSPPrincipal_Classification = 0
	// one of a member of MSP network, and the one of an
	// administrator of an MSP network
	MSPPrincipal_ORGANIZATION_UNIT MSPPrincipal_Classification = 1
	// groupping of entities, per MSP affiliation
	// E.g., this can well be represented by an MSP's
	// Organization unit
	MSPPrincipal_IDENTITY MSPPrincipal_Classification = 2
)

var MSPPrincipal_Classification_name = map[int32]string{
	0: "ROLE",
	1: "ORGANIZATION_UNIT",
	2: "IDENTITY",
}
var MSPPrincipal_Classification_value = map[string]int32{
	"ROLE":              0,
	"ORGANIZATION_UNIT": 1,
	"IDENTITY":          2,
}

func (x MSPPrincipal_Classification) String() string {
	return proto.EnumName(MSPPrincipal_Classification_name, int32(x))
}
func (MSPPrincipal_Classification) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMspPrincipal, []int{0, 0}
}

type MSPRole_MSPRoleType int32

const (
	MSPRole_MEMBER MSPRole_MSPRoleType = 0
	MSPRole_ADMIN  MSPRole_MSPRoleType = 1
)

var MSPRole_MSPRoleType_name = map[int32]string{
	0: "MEMBER",
	1: "ADMIN",
}
var MSPRole_MSPRoleType_value = map[string]int32{
	"MEMBER": 0,
	"ADMIN":  1,
}

func (x MSPRole_MSPRoleType) String() string {
	return proto.EnumName(MSPRole_MSPRoleType_name, int32(x))
}
func (MSPRole_MSPRoleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMspPrincipal, []int{2, 0}
}

// MSPPrincipal aims to represent an MSP-centric set of identities.
// In particular, this structure allows for definition of
//  - a group of identities that are member of the same MSP
//  - a group of identities that are member of the same organization unit
//    in the same MSP
//  - a group of identities that are administering a specific MSP
//  - a specific identity
// Expressing these groups is done given two fields of the fields below
//  - Classification, that defines the type of classification of identities
//    in an MSP this principal would be defined on; Classification can take
//    three values:
//     (i)  ByMSPRole: that represents a classification of identities within
//          MSP based on one of the two pre-defined MSP rules, "member" and "admin"
//     (ii) ByOrganizationUnit: that represents a classification of identities
//          within MSP based on the organization unit an identity belongs to
//     (iii)ByIdentity that denotes that MSPPrincipal is mapped to a single
//          identity/certificate; this would mean that the Principal bytes
//          message
type MSPPrincipal struct {
	// Classification describes the way that one should process
	// Principal. An Classification value of "ByOrganizationUnit" reflects
	// that "Principal" contains the name of an organization this MSP
	// handles. A Classification value "ByIdentity" means that
	// "Principal" contains a specific identity. Default value
	// denotes that Principal contains one of the groups by
	// default supported by all MSPs ("admin" or "member").
	PrincipalClassification MSPPrincipal_Classification `protobuf:"varint,1,opt,name=principal_classification,json=principalClassification,proto3,enum=common.MSPPrincipal_Classification" json:"principal_classification,omitempty"`
	// Principal completes the policy principal definition. For the default
	// principal types, Principal can be either "Admin" or "Member".
	// For the ByOrganizationUnit/ByIdentity values of Classification,
	// PolicyPrincipal acquires its value from an organization unit or
	// identity, respectively.
	Principal []byte `protobuf:"bytes,2,opt,name=principal,proto3" json:"principal,omitempty"`
}

func (m *MSPPrincipal) Reset()                    { *m = MSPPrincipal{} }
func (m *MSPPrincipal) String() string            { return proto.CompactTextString(m) }
func (*MSPPrincipal) ProtoMessage()               {}
func (*MSPPrincipal) Descriptor() ([]byte, []int) { return fileDescriptorMspPrincipal, []int{0} }

func (m *MSPPrincipal) GetPrincipalClassification() MSPPrincipal_Classification {
	if m != nil {
		return m.PrincipalClassification
	}
	return MSPPrincipal_ROLE
}

func (m *MSPPrincipal) GetPrincipal() []byte {
	if m != nil {
		return m.Principal
	}
	return nil
}

// OrganizationUnit governs the organization of the Principal
// field of a policy principal when a specific organization unity members
// are to be defined within a policy principal.
type OrganizationUnit struct {
	// MSPIdentifier represents the identifier of the MSP this organization unit
	// refers to
	MspIdentifier string `protobuf:"bytes,1,opt,name=msp_identifier,json=mspIdentifier,proto3" json:"msp_identifier,omitempty"`
	// OrganizationUnitIdentifier defines the organizational unit under the
	// MSP identified with MSPIdentifier
	OrganizationalUnitIdentifier string `protobuf:"bytes,2,opt,name=organizational_unit_identifier,json=organizationalUnitIdentifier,proto3" json:"organizational_unit_identifier,omitempty"`
	// CertifiersIdentifier is the hash of certificates chain of trust
	// related to this organizational unit
	CertifiersIdentifier []byte `protobuf:"bytes,3,opt,name=certifiers_identifier,json=certifiersIdentifier,proto3" json:"certifiers_identifier,omitempty"`
}

func (m *OrganizationUnit) Reset()                    { *m = OrganizationUnit{} }
func (m *OrganizationUnit) String() string            { return proto.CompactTextString(m) }
func (*OrganizationUnit) ProtoMessage()               {}
func (*OrganizationUnit) Descriptor() ([]byte, []int) { return fileDescriptorMspPrincipal, []int{1} }

func (m *OrganizationUnit) GetMspIdentifier() string {
	if m != nil {
		return m.MspIdentifier
	}
	return ""
}

func (m *OrganizationUnit) GetOrganizationalUnitIdentifier() string {
	if m != nil {
		return m.OrganizationalUnitIdentifier
	}
	return ""
}

func (m *OrganizationUnit) GetCertifiersIdentifier() []byte {
	if m != nil {
		return m.CertifiersIdentifier
	}
	return nil
}

// MSPRole governs the organization of the Principal
// field of an MSPPrincipal when it aims to define one of the
// two dedicated roles within an MSP: Admin and Members.
type MSPRole struct {
	// MSPIdentifier represents the identifier of the MSP this principal
	// refers to
	MspIdentifier string `protobuf:"bytes,1,opt,name=msp_identifier,json=mspIdentifier,proto3" json:"msp_identifier,omitempty"`
	// MSPRoleType defines which of the available, pre-defined MSP-roles
	// an identiy should posess inside the MSP with identifier MSPidentifier
	Role MSPRole_MSPRoleType `protobuf:"varint,2,opt,name=role,proto3,enum=common.MSPRole_MSPRoleType" json:"role,omitempty"`
}

func (m *MSPRole) Reset()                    { *m = MSPRole{} }
func (m *MSPRole) String() string            { return proto.CompactTextString(m) }
func (*MSPRole) ProtoMessage()               {}
func (*MSPRole) Descriptor() ([]byte, []int) { return fileDescriptorMspPrincipal, []int{2} }

func (m *MSPRole) GetMspIdentifier() string {
	if m != nil {
		return m.MspIdentifier
	}
	return ""
}

func (m *MSPRole) GetRole() MSPRole_MSPRoleType {
	if m != nil {
		return m.Role
	}
	return MSPRole_MEMBER
}

func init() {
	proto.RegisterType((*MSPPrincipal)(nil), "common.MSPPrincipal")
	proto.RegisterType((*OrganizationUnit)(nil), "common.OrganizationUnit")
	proto.RegisterType((*MSPRole)(nil), "common.MSPRole")
	proto.RegisterEnum("common.MSPPrincipal_Classification", MSPPrincipal_Classification_name, MSPPrincipal_Classification_value)
	proto.RegisterEnum("common.MSPRole_MSPRoleType", MSPRole_MSPRoleType_name, MSPRole_MSPRoleType_value)
}
func (m *MSPPrincipal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MSPPrincipal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PrincipalClassification != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMspPrincipal(dAtA, i, uint64(m.PrincipalClassification))
	}
	if len(m.Principal) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMspPrincipal(dAtA, i, uint64(len(m.Principal)))
		i += copy(dAtA[i:], m.Principal)
	}
	return i, nil
}

func (m *OrganizationUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrganizationUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MspIdentifier) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspPrincipal(dAtA, i, uint64(len(m.MspIdentifier)))
		i += copy(dAtA[i:], m.MspIdentifier)
	}
	if len(m.OrganizationalUnitIdentifier) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMspPrincipal(dAtA, i, uint64(len(m.OrganizationalUnitIdentifier)))
		i += copy(dAtA[i:], m.OrganizationalUnitIdentifier)
	}
	if len(m.CertifiersIdentifier) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMspPrincipal(dAtA, i, uint64(len(m.CertifiersIdentifier)))
		i += copy(dAtA[i:], m.CertifiersIdentifier)
	}
	return i, nil
}

func (m *MSPRole) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MSPRole) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MspIdentifier) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspPrincipal(dAtA, i, uint64(len(m.MspIdentifier)))
		i += copy(dAtA[i:], m.MspIdentifier)
	}
	if m.Role != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMspPrincipal(dAtA, i, uint64(m.Role))
	}
	return i, nil
}

func encodeFixed64MspPrincipal(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32MspPrincipal(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMspPrincipal(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MSPPrincipal) Size() (n int) {
	var l int
	_ = l
	if m.PrincipalClassification != 0 {
		n += 1 + sovMspPrincipal(uint64(m.PrincipalClassification))
	}
	l = len(m.Principal)
	if l > 0 {
		n += 1 + l + sovMspPrincipal(uint64(l))
	}
	return n
}

func (m *OrganizationUnit) Size() (n int) {
	var l int
	_ = l
	l = len(m.MspIdentifier)
	if l > 0 {
		n += 1 + l + sovMspPrincipal(uint64(l))
	}
	l = len(m.OrganizationalUnitIdentifier)
	if l > 0 {
		n += 1 + l + sovMspPrincipal(uint64(l))
	}
	l = len(m.CertifiersIdentifier)
	if l > 0 {
		n += 1 + l + sovMspPrincipal(uint64(l))
	}
	return n
}

func (m *MSPRole) Size() (n int) {
	var l int
	_ = l
	l = len(m.MspIdentifier)
	if l > 0 {
		n += 1 + l + sovMspPrincipal(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovMspPrincipal(uint64(m.Role))
	}
	return n
}

func sovMspPrincipal(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMspPrincipal(x uint64) (n int) {
	return sovMspPrincipal(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MSPPrincipal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspPrincipal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MSPPrincipal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MSPPrincipal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrincipalClassification", wireType)
			}
			m.PrincipalClassification = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspPrincipal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrincipalClassification |= (MSPPrincipal_Classification(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Principal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspPrincipal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMspPrincipal
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Principal = append(m.Principal[:0], dAtA[iNdEx:postIndex]...)
			if m.Principal == nil {
				m.Principal = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspPrincipal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspPrincipal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrganizationUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspPrincipal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrganizationUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrganizationUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MspIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspPrincipal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMspPrincipal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MspIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationalUnitIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspPrincipal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMspPrincipal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationalUnitIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertifiersIdentifier", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspPrincipal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMspPrincipal
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertifiersIdentifier = append(m.CertifiersIdentifier[:0], dAtA[iNdEx:postIndex]...)
			if m.CertifiersIdentifier == nil {
				m.CertifiersIdentifier = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspPrincipal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspPrincipal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MSPRole) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspPrincipal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MSPRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MSPRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MspIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspPrincipal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMspPrincipal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MspIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspPrincipal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= (MSPRole_MSPRoleType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMspPrincipal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspPrincipal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMspPrincipal(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMspPrincipal
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMspPrincipal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMspPrincipal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMspPrincipal
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMspPrincipal
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMspPrincipal(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMspPrincipal = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMspPrincipal   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("msp/msp_principal.proto", fileDescriptorMspPrincipal) }

var fileDescriptorMspPrincipal = []byte{
	// 409 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x92, 0x51, 0x8e, 0x93, 0x40,
	0x18, 0xc7, 0x3b, 0x75, 0xad, 0xdb, 0xcf, 0x4a, 0x70, 0xe2, 0x66, 0x9b, 0xb8, 0x21, 0x1b, 0x5c,
	0x93, 0x3e, 0x41, 0xb2, 0x7b, 0x00, 0xd3, 0xb5, 0xc4, 0x90, 0x08, 0x34, 0xb3, 0xec, 0x83, 0xfb,
	0x20, 0x52, 0x3a, 0xa5, 0x93, 0x00, 0x33, 0x19, 0xe8, 0x43, 0xbd, 0x80, 0x57, 0xf0, 0x20, 0x1e,
	0xc2, 0x17, 0x13, 0x8f, 0x60, 0xea, 0x45, 0x0c, 0x60, 0xe9, 0xd4, 0x27, 0x9f, 0x60, 0xbe, 0xff,
	0xef, 0xf7, 0xcd, 0x0c, 0x7c, 0x70, 0x9e, 0x97, 0xc2, 0xce, 0x4b, 0x11, 0x09, 0xc9, 0x8a, 0x84,
	0x89, 0x38, 0xb3, 0x84, 0xe4, 0x15, 0xc7, 0x83, 0x84, 0xe7, 0x39, 0x2f, 0xcc, 0x1f, 0x08, 0x46,
	0xde, 0xdd, 0x7c, 0xbe, 0x8f, 0xf1, 0x47, 0x18, 0x77, 0x6c, 0x94, 0x64, 0x71, 0x59, 0xb2, 0x15,
	0x4b, 0xe2, 0x8a, 0xf1, 0x62, 0x8c, 0x2e, 0xd1, 0x44, 0xbb, 0x7e, 0x65, 0xb5, 0xae, 0xa5, 0x7a,
	0xd6, 0xdb, 0x23, 0x94, 0x9c, 0x77, 0x4d, 0x8e, 0x03, 0x7c, 0x01, 0xc3, 0x2e, 0x1a, 0xf7, 0x2f,
	0xd1, 0x64, 0x44, 0x0e, 0x05, 0xf3, 0x0d, 0x68, 0xff, 0xf0, 0xa7, 0x70, 0x42, 0x82, 0xf7, 0x8e,
	0xde, 0xc3, 0x67, 0xf0, 0x3c, 0x20, 0xef, 0xa6, 0xbe, 0xfb, 0x30, 0x0d, 0xdd, 0xc0, 0x8f, 0xee,
	0x7d, 0x37, 0xd4, 0x11, 0x1e, 0xc1, 0xa9, 0x3b, 0x73, 0xfc, 0xd0, 0x0d, 0x3f, 0xe8, 0x7d, 0xf3,
	0x1b, 0x02, 0x3d, 0x90, 0x69, 0x5c, 0xb0, 0xcf, 0x8d, 0x7f, 0x5f, 0xb0, 0x0a, 0xbf, 0x06, 0xad,
	0xfe, 0x06, 0x6c, 0x49, 0x8b, 0x8a, 0xad, 0x18, 0x95, 0xcd, 0x4d, 0x86, 0xe4, 0x59, 0x5e, 0x0a,
	0xb7, 0x2b, 0xe2, 0x19, 0x18, 0x5c, 0x51, 0xe3, 0x2c, 0xda, 0x14, 0xac, 0x52, 0xb5, 0x7e, 0xa3,
	0x5d, 0x1c, 0x53, 0xf5, 0x16, 0x4a, 0x97, 0x1b, 0x38, 0x4b, 0xa8, 0x6c, 0x17, 0xa5, 0x2a, 0x3f,
	0x6a, 0x2e, 0xfb, 0xe2, 0x10, 0x1e, 0x24, 0xf3, 0x0b, 0x82, 0x27, 0xde, 0xdd, 0x9c, 0xf0, 0x8c,
	0xfe, 0xef, 0x69, 0x6d, 0x38, 0x91, 0x3c, 0xa3, 0xcd, 0x99, 0xb4, 0xeb, 0x97, 0xca, 0x4f, 0xa9,
	0xbb, 0xec, 0x9f, 0xe1, 0x56, 0x50, 0xd2, 0x80, 0xe6, 0x15, 0x3c, 0x55, 0x8a, 0x18, 0x60, 0xe0,
	0x39, 0xde, 0xad, 0x43, 0xf4, 0x1e, 0x1e, 0xc2, 0xe3, 0xe9, 0xcc, 0x73, 0x7d, 0x1d, 0xdd, 0x7e,
	0xfa, 0xbe, 0x33, 0xd0, 0xcf, 0x9d, 0x81, 0x7e, 0xed, 0x0c, 0xf4, 0xf5, 0xb7, 0xd1, 0x83, 0x2b,
	0x2e, 0x53, 0x6b, 0xbd, 0x15, 0x54, 0x66, 0x74, 0x99, 0x52, 0x69, 0xad, 0xe2, 0x85, 0x64, 0x49,
	0x3b, 0x48, 0xe5, 0xdf, 0x7d, 0x1f, 0x26, 0x29, 0xab, 0xd6, 0x9b, 0x45, 0xbd, 0xb4, 0x15, 0xd8,
	0x6e, 0x61, 0xbb, 0x85, 0xeb, 0x51, 0x5c, 0x0c, 0x9a, 0xf7, 0x9b, 0x3f, 0x01, 0x00, 0x00, 0xff,
	0xff, 0x12, 0x45, 0x44, 0xa7, 0x9c, 0x02, 0x00, 0x00,
}
